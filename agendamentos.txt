Sem problemas! Você pode combinar os dois tipos de respostas em um único array e ordená-los. Vamos assumir que você tenha duas interfaces: `AgendarExameResponse` e `AgendarConsultaResponse`.

Aqui está como você pode fazer isso:

1. **Defina uma interface comum** que represente um agendamento, incluindo as propriedades que você precisa.
2. **Misture os dois arrays** e mapeie-os para essa interface comum.
3. **Ordene o novo array** e exiba os dados.

### Exemplo de Implementação

#### Definição das Interfaces

```typescript
interface AgendarExameResponse {
  dataAgendamento: Date;
  tipo: 'exame';
  // outras propriedades específicas do exame...
}

interface AgendarConsultaResponse {
  dataAgendamento: Date;
  tipo: 'consulta';
  // outras propriedades específicas da consulta...
}

// Interface comum para os agendamentos
interface Agendamento {
  dataAgendamento: Date;
  tipo: 'exame' | 'consulta';
  // outras propriedades comuns, se necessário...
}
```

#### Componente

```typescript
import { Component } from '@angular/core';
import { Location } from '@angular/common';

@Component({
  selector: 'app-admin-historico-agendamentos',
  templateUrl: './admin-historico-agendamentos.component.html',
  styleUrls: ['./admin-historico-agendamentos.component.css']
})
export class AdminHistoricoAgendamentosComponent {
  proximosExames: AgendarExameResponse[] = [];
  proximasConsultas: AgendarConsultaResponse[] = [];
  agendamentos: Agendamento[] = [];

  constructor(private location: Location) {
    this.mixAndSortAgendamentos();
  }

  private mixAndSortAgendamentos() {
    const exames: Agendamento[] = this.proximosExames.map(exame => ({
      dataAgendamento: exame.dataAgendamento,
      tipo: 'exame',
      // adicione outras propriedades se necessário
    }));

    const consultas: Agendamento[] = this.proximasConsultas.map(consulta => ({
      dataAgendamento: consulta.dataAgendamento,
      tipo: 'consulta',
      // adicione outras propriedades se necessário
    }));

    this.agendamentos = [...exames, ...consultas];

    this.agendamentos.sort((a, b) => +new Date(a.dataAgendamento) - +new Date(b.dataAgendamento));
  }
}
```

### Template

Agora, para exibir os agendamentos, você pode usar o mesmo `*ngFor`:

```html
<section class="grid gap-5 place-content-center">
  <ng-container *ngFor="let agendamento of agendamentos">
    <app-ultimos-pacientes-card
      [proximosExames]="agendamento.tipo === 'exame' ? [agendamento] : []"
      [proximasConsultas]="agendamento.tipo === 'consulta' ? [agendamento] : []"
      tela="agendamentos-paciente">
    </app-ultimos-pacientes-card>
  </ng-container>
</section>
```

### Resumo

- **Interface comum**: Criamos uma interface comum para facilitar a manipulação dos dados.
- **Mistura e ordenação**: Misturamos os arrays de exames e consultas, ordenando-os pela data de agendamento.
- **Exibição**: Usamos `*ngFor` para exibir os agendamentos de forma ordenada.

Isso deve atender ao que você precisa! Se precisar de mais ajustes ou explicações, é só avisar.

Para manter a lógica do componente UltimosPacientesCardComponent considerando a nova estrutura de dados que combina exames e consultas, você pode modificar a lógica de redirecionamento. Isso envolve alterar a maneira como você trata os agendamentos ao verificar se é um exame ou uma consulta.

Aqui está como você pode ajustar o componente:

Componente Ajustado
typescript
Copiar código
import { Component, Input } from '@angular/core';
import { Router } from '@angular/router';
import { PacienteService } from 'src/app/services/paciente.service';
import { PacienteResponseContract } from 'src/app/models/paciente-response-contract';
import { AgendarExameResponse } from 'src/app/models/agendar-exame-response';
import { AgendarConsultaResponse } from 'src/app/models/agendar-consulta-response';

@Component({
  selector: 'app-ultimos-pacientes-card',
  templateUrl: './ultimos-pacientes-card.component.html',
  styleUrls: ['./ultimos-pacientes-card.component.css']
})
export class UltimosPacientesCardComponent {
  @Input() ultimosPacientes: PacienteResponseContract[] = [];
  @Input() proximosExames: AgendarExameResponse[] = [];
  @Input() proximasConsultas: AgendarConsultaResponse[] = []; // Adiciona a entrada para consultas
  @Input() tela: string = '';

  constructor(private router: Router, private pacienteService: PacienteService) {}

  redirecionarParaConsulta(agendamento: AgendarExameResponse | AgendarConsultaResponse) {
    if (agendamento.tipo === 'exame') {
      this.acessarExame(agendamento.id); // Certifique-se de que o ID está acessível
    } else {
      this.acessarConsulta(agendamento.id); // Certifique-se de que o ID está acessível
    }
  }

  redirecionarParaPaciente(paciente: PacienteResponseContract) {
    if (this.tela === "historico") {
      this.acessarPaciente(paciente.id);
    } else {
      this.acessarPacienteAdmin(paciente.id);
    }
  }

  acessarConsulta(consultaId: number) {
    this.router.navigate(['medico/consulta-detalhes', consultaId]);
  }

  acessarExame(exameId: number) {
    this.router.navigate(['medico/exame-detalhes', exameId]);
  }

  acessarPacienteAdmin(pacienteId: number) {
    this.router.navigate(['admin/historico/agendamentos-paciente', pacienteId]);
  }

  acessarPaciente(pacienteId: number) {
    this.router.navigate(['medico/detalhes-paciente', pacienteId]);
  }
}
Ajustes na Template
Ao fazer uso deste componente, você precisará garantir que, ao redirecionar, você esteja passando o objeto correto (se é um exame ou uma consulta) para o método redirecionarParaConsulta. Por exemplo:

html
Copiar código
<section class="grid gap-5 place-content-center">
  <ng-container *ngFor="let agendamento of agendamentos">
    <app-ultimos-pacientes-card
      [ultimosPacientes]="ultimosPacientes"
      [proximosExames]="agendamento.tipo === 'exame' ? [agendamento] : []"
      [proximasConsultas]="agendamento.tipo === 'consulta' ? [agendamento] : []"
      [tela]="tela">
    </app-ultimos-pacientes-card>
  </ng-container>
</section>
Resumo das Mudanças
Input para Consultas: Adicionei uma propriedade proximasConsultas ao componente para receber os dados de consultas.
Lógica de Redirecionamento: Modifiquei o método redirecionarParaConsulta para aceitar um único agendamento que pode ser um exame ou uma consulta e redirecioná-lo adequadamente.
Template: Ajuste no ngFor para passar o agendamento correto para o card, permitindo que ele saiba se é um exame ou uma consulta.
Com essas modificações, seu componente deve funcionar corretamente, mantendo a lógica que você já tinha, mas agora adaptando-a à nova estrutura de dados. Se precisar de mais detalhes ou ajustes, é só avisar!
